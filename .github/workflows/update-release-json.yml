# .github/workflows/update-release-json.yml in tollgate-os
name: Update Release JSON with Real Events

on:
  push:
    branches:
      - '*'
    paths:
      - '.github/workflows/update-release-json.yml'
      - 'actions/update-from-nip94/**'
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Run ID of the build workflow'
        required: true
  repository_dispatch:
    types: [update-release-json]

# Add permissions block here
permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: develop
          token: ${{ secrets.REPOSCOPE }}
          clean: true
          persist-credentials: false
          fetch-depth: 0

      - name: Verify Action Exists
        run: |
          echo "Checking for action.yml file..."
          if [ -f "actions/update-from-nip94/action.yml" ]; then
            echo "✅ Action file found!"
            cat actions/update-from-nip94/action.yml | head -10
          else
            echo "❌ Action file NOT found!"
            echo "Current directory structure:"
            find . -name "actions" -type d | xargs ls -la 2>/dev/null || echo "No actions directory"
            
            echo "Commit information:"
            git log -1 --stat
          fi

      - name: Install nak
        run: |
          sudo wget https://github.com/fiatjaf/nak/releases/download/v0.12.4/nak-v0.12.4-linux-amd64 -O /usr/local/bin/nak
          sudo chmod +x /usr/local/bin/nak
    
      - name: Verify Event on Network with nak
        run: |
          # Get the pubkey from secrets
          PUBKEY="${{ secrets.NIP_94_PUBKEY }}"
          
          if [ -z "$PUBKEY" ]; then
            echo "::error::NIP_94_PUBKEY secret is not set"
            exit 1
          fi
          
          echo "Fetching recent NIP-94 events for pubkey: $PUBKEY"
          nak req -a "$PUBKEY" -k 1063 --limit 50 wss://relay.damus.io > event_response.txt
          
          # Extract only the event data (removing connection messages)
          cat event_response.txt | grep -v "connecting to" | grep -v "NOTICE" > events_data.txt
          
          # Create directory for events
          mkdir -p event_files
          
          # Process and save events
          cat events_data.txt | jq . > event_files/all_events.json
          cat event_files/all_events.json | jq -c '.tags[] | select(.[0] == "filename")[1]' | sort | uniq
          
      - name: Extract and Sort Events by Timestamp
        run: |
          mkdir -p sorted_events
          
          echo "Extracting and sorting NIP-94 events by timestamp..."
          
          # Process each event in events_data.txt
          cat events_data.txt | jq -c '.' | while read -r event; do
            # Extract key information
            EVENT_ID=$(echo "$event" | jq -r '.id')
            CREATED_AT=$(echo "$event" | jq -r '.created_at')
            ARCH=$(echo "$event" | jq -r '.tags[] | select(.[0] == "arch") | .[1] // "unknown"')
            FILENAME=$(echo "$event" | jq -r '.tags[] | select(.[0] == "filename") | .[1] // "unknown"')
            URL=$(echo "$event" | jq -r '.tags[] | select(.[0] == "url") | .[1] // ""')
            HASH=$(echo "$event" | jq -r '.tags[] | select(.[0] == "x") | .[1] // ""')
            
            # Skip events with missing URL or hash
            if [[ -z "$URL" || -z "$HASH" ]]; then
              echo "⚠️ Skipping event $EVENT_ID: Missing URL or hash"
              continue
            fi
            
            # Extract module name from filename
            MODULE=""
            if [[ "$FILENAME" =~ ^([^-]+)- ]]; then
              MODULE="${BASH_REMATCH[1]}"
            elif [[ "$FILENAME" =~ tollgate-module-(.+)-go ]]; then
              MODULE="${BASH_REMATCH[1]}"
            fi
            
            if [[ -n "$MODULE" && -n "$ARCH" ]]; then
              # Create a unique key for this module/architecture
              KEY="${MODULE}-${ARCH}"
              
              # Create sorted filename (timestamp_key_eventid.json)
              # Zero-pad timestamp to ensure proper sorting
              SORTED_FILE="sorted_events/$(printf "%020d" $CREATED_AT)_${KEY}_${EVENT_ID}.json"
              
              echo "$event" > "$SORTED_FILE"
              echo "Saved event $EVENT_ID (created: $CREATED_AT) for $KEY to $SORTED_FILE"
            else
              echo "⚠️ Skipping event $EVENT_ID: Missing module ($MODULE) or architecture ($ARCH)"
            fi
          done
          
          echo "Creating newest_events directory for only the latest events..."
          mkdir -p newest_events
          
          # Find the newest event for each module/architecture
          # List files in reverse order (newest first)
          declare -A processed_keys
          counter=0
          
          for file in $(ls -r sorted_events/*.json); do
            # Extract key from filename
            filename=$(basename "$file")
            key=$(echo "$filename" | sed -E 's/^[0-9]+_(.+)_.+\.json$/\1/')
            
            if [[ -z "${processed_keys[$key]}" ]]; then
              # This is the first (newest) occurrence of this key
              processed_keys[$key]=1
              # Use simple, sequential filenames that the action will recognize
              cp "$file" "newest_events/event_${counter}.json"
              created_at=$(echo "$filename" | sed -E 's/^0*([0-9]+)_.+$/\1/')
              echo "✅ Using newest event for $key (created_at: $created_at) as event_${counter}.json"
              # Display the hash of the event for verification
              HASH=$(cat "$file" | jq -r '.tags[] | select(.[0] == "x") | .[1] // "no-hash-found"')
              echo "   Hash: $HASH"
              counter=$((counter+1))
            else
              echo "⏭️ Skipping older event for $key: $file"
            fi
          done
          
          echo "Processed ${#processed_keys[@]} unique module/architecture combinations"
          echo "Contents of newest_events directory:"
          ls -la newest_events/
          
          # Display the content of each event file for debugging
          echo "Event file contents:"
          for file in newest_events/*.json; do
            echo "=== $file ==="
            cat "$file" | jq '.'
            echo ""
          done

      # Debug the action parameters
      - name: Debug Action Parameters
        run: |
          echo "Action will use artifacts_path: newest_events"
          echo "File list in newest_events:"
          find newest_events -type f | sort
          echo "Contents of the first file (if any):"
          if [ -f "$(find newest_events -type f | head -n1)" ]; then
            cat "$(find newest_events -type f | head -n1)"
          else
            echo "No files found"
          fi

      - name: Examine Action Implementation
        run: |
          echo "Checking how the action finds JSON files:"
          grep -r "find.*json" actions/update-from-nip94/ || echo "No find command for JSON files found"
          grep -r "ls.*json" actions/update-from-nip94/ || echo "No ls command for JSON files found"
          
          echo "Checking how the action processes event files:"
          if [ -f "actions/update-from-nip94/action.yml" ]; then
            cat actions/update-from-nip94/action.yml
          fi
          
          # Copy events to the exact format the action might expect
          mkdir -p event_files
          cp newest_events/*.json event_files/
          echo "Copied files to event_files directory as fallback"

      - name: Final Update Release JSON
        uses: ./actions/update-from-nip94
        with:
          artifacts_path: newest_events  # Use our preprocessed directory with only the newest events
          release_json_path: release.json
          target_branch: develop
          github_token: ${{ secrets.REPOSCOPE }}
          commit_message: "Update release.json with latest NIP-94 events"


      # - name: Download SDK Artifacts
      #   uses: dawidd6/action-download-artifact@v2
      #   with:
      #     run_id: ${{ github.event.client_payload.sdk_run_id }}
      #     repo: OpenTollGate/tollgate-sdk
      #     github_token: ${{ secrets.REPOSCOPE }}
      #     path: sdk-artifacts
      #     check_artifacts: true
      #     # Use the array directly without fromJson()
      #     name: ${{ join(github.event.client_payload.artifacts, ',') }}

      # - name: Process Real Events
      #   run: |
      #     echo "Real artifacts downloaded:"
      #     find sdk-artifacts -type f | sort
      #     # Verify NIP-94 event files exist
      #     if [ $(find sdk-artifacts -name '*-event.json' | wc -l) -eq 0 ]; then
      #       echo "::error::No NIP-94 event files found!"
      #       exit 1
      #     fi

      # - name: Update Release JSON
      #   uses: ./actions/update-release-json
      #   with:
      #     artifacts_path: sdk-artifacts  # Changed from artifacts
      #     release_json_path: release.json
      #     target_branch: develop
      #     github_token: ${{ secrets.REPOSCOPE }}
      #     commit_message: "Update release.json with real NIP-94 events [skip ci]"

      # - name: Debug Incoming Payload
      #   run: |
      #     echo "Full event payload:"
      #     echo '${{ toJSON(github.event) }}' | jq .
          
      #     echo "Client payload contents:"
      #     echo '${{ toJSON(github.event.client_payload) }}' | jq .
          
      #     echo "NIP-94 events data:"
      #     echo '${{ toJSON(github.event.client_payload.nip94_events) }}' | jq .
          
      #     # Write to a file for validation
      #     mkdir -p debug
      #     echo '${{ toJSON(github.event.client_payload.nip94_events) }}' > debug/received_events.json
      #     echo "Stored events in debug/received_events.json"

      # - name: Validate Event Structure
      #   run: |
      #     if [ ! -s "debug/received_events.json" ]; then
      #       echo "::error::No events data received!"
      #       exit 1
      #     fi
          
      #     # Validate JSON structure
      #     if ! jq empty debug/received_events.json; then
      #       echo "::error::Invalid JSON structure in received events"
      #       jq . debug/received_events.json
      #       exit 1
      #     fi
          
      #     # Check for at least one event
      #     EVENT_COUNT=$(jq '.events | length' debug/received_events.json)
      #     if [ "$EVENT_COUNT" -eq 0 ]; then
      #       echo "::warning::Received empty events array"
      #     else
      #       echo "Received $EVENT_COUNT valid NIP-94 events"
      #     fi

